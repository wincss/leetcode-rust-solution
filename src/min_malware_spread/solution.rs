use crate::*;

use std::collections::HashMap;
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        fn find<T>(x: &T, parent: &mut HashMap<T, T>, size: &mut HashMap<T, usize>) -> T
        where
            T: std::cmp::Eq + std::hash::Hash + Clone,
        {
            let f = parent.entry(x.clone()).or_insert(x.clone());
            size.entry(x.clone()).or_insert(1);
            if *f == *x {
                x.clone()
            } else {
                let p = find(&f.clone(), parent, size);
                parent.insert(x.clone(), p.clone());
                p
            }
        }
        fn union<T>(x: &T, y: &T, parent: &mut HashMap<T, T>, size: &mut HashMap<T, usize>)
        where
            T: std::cmp::Eq + std::hash::Hash + Clone,
        {
            let x = find(x, parent, size);
            let y = find(y, parent, size);
            if size[&x] > size[&y] {
                parent.insert(y.clone(), x.clone());
                size.insert(x.clone(), size[&x] + size[&y]);
            } else {
                parent.insert(x.clone(), y.clone());
                size.insert(y.clone(), size[&x] + size[&y]);
            }
        }
        let mut parent = HashMap::new();
        let mut size = HashMap::new();
        for (i, v) in graph.iter().enumerate() {
            for (j, &connected) in v.iter().enumerate() {
                if connected == 1 {
                    union(&i, &j, &mut parent, &mut size);
                }
            }
        }
        let mut initial = initial;
        let mut effect = vec![0; initial.len()];
        let mut infected_by = HashMap::new();
        initial.sort();
        for (i, &k) in initial.iter().enumerate() {
            let group = find(&(k as usize), &mut parent, &mut size);
            if let Some(&v) = infected_by.get(&group) {
                effect[v] = 0;
                effect[i] = 0;
            } else {
                effect[i] = size[&group];
                infected_by.insert(group, i);
            }
        }
        // println!("initial={:?}, effect={:?}", initial, effect);
        let mut result = 0;
        let mut maxeff = -1;
        for (i, v) in effect.into_iter().enumerate() {
            if v as i32 > maxeff {
                maxeff = v as i32;
                result = initial[i];
            }
        }
        result
    }
}
